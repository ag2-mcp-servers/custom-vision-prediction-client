# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T05:08:44+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union
from uuid import UUID

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Path, UploadFile
from starlette.requests import Request

from models import CustomVisionError, ImagePrediction, ImageUrl

app = MCPProxy(
    contact={'x-twitter': 'microsoft'},
    title='Custom Vision Prediction Client',
    version='3.0',
    servers=[
        {
            'url': 'https://southcentralus.api.cognitive.microsoft.com/customvision/v3.0/prediction'
        },
        {
            'url': '{Endpoint}/customvision/v3.0/prediction',
            'variables': {
                'Endpoint': {
                    'default': 'none',
                    'description': 'Supported Cognitive Services endpoints.',
                    'x-ms-parameter-location': 'client',
                    'x-ms-skip-url-encoding': True,
                }
            },
        },
    ],
)


@app.post(
    '/{projectId}/classify/iterations/{publishedName}/image',
    tags=['image_classification'],
    security=[
        APIKeyHeader(name="Prediction-Key"),
    ],
)
def classify_image(
    project_id: UUID = Path(..., alias='projectId'),
    published_name: str = Path(..., alias='publishedName'),
    application: Optional[str] = None,
    file: UploadFile = ...,
):
    """
    Classify an image and saves the result.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/{projectId}/classify/iterations/{publishedName}/image/nostore',
    tags=['image_classification'],
    security=[
        APIKeyHeader(name="Prediction-Key"),
    ],
)
def classify_image_with_no_store(
    project_id: UUID = Path(..., alias='projectId'),
    published_name: str = Path(..., alias='publishedName'),
    application: Optional[str] = None,
    file: UploadFile = ...,
):
    """
    Classify an image without saving the result.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/{projectId}/classify/iterations/{publishedName}/url',
    tags=['image_classification'],
    security=[
        APIKeyHeader(name="Prediction-Key"),
    ],
)
def classify_image_url(
    project_id: UUID = Path(..., alias='projectId'),
    published_name: str = Path(..., alias='publishedName'),
    application: Optional[str] = None,
    body: ImageUrl = ...,
):
    """
    Classify an image url and saves the result.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/{projectId}/classify/iterations/{publishedName}/url/nostore',
    tags=['image_classification'],
    security=[
        APIKeyHeader(name="Prediction-Key"),
    ],
)
def classify_image_url_with_no_store(
    project_id: UUID = Path(..., alias='projectId'),
    published_name: str = Path(..., alias='publishedName'),
    application: Optional[str] = None,
    body: ImageUrl = ...,
):
    """
    Classify an image url without saving the result.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/{projectId}/detect/iterations/{publishedName}/image',
    tags=['object_detection'],
    security=[
        APIKeyHeader(name="Prediction-Key"),
    ],
)
def detect_image(
    project_id: UUID = Path(..., alias='projectId'),
    published_name: str = Path(..., alias='publishedName'),
    application: Optional[str] = None,
    file: UploadFile = ...,
):
    """
    Detect objects in an image and saves the result.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/{projectId}/detect/iterations/{publishedName}/image/nostore',
    tags=['object_detection'],
    security=[
        APIKeyHeader(name="Prediction-Key"),
    ],
)
def detect_image_with_no_store(
    project_id: UUID = Path(..., alias='projectId'),
    published_name: str = Path(..., alias='publishedName'),
    application: Optional[str] = None,
    file: UploadFile = ...,
):
    """
    Detect objects in an image without saving the result.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/{projectId}/detect/iterations/{publishedName}/url',
    tags=['object_detection'],
    security=[
        APIKeyHeader(name="Prediction-Key"),
    ],
)
def detect_image_url(
    project_id: UUID = Path(..., alias='projectId'),
    published_name: str = Path(..., alias='publishedName'),
    application: Optional[str] = None,
    body: ImageUrl = ...,
):
    """
    Detect objects in an image url and saves the result.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/{projectId}/detect/iterations/{publishedName}/url/nostore',
    tags=['object_detection'],
    security=[
        APIKeyHeader(name="Prediction-Key"),
    ],
)
def detect_image_url_with_no_store(
    project_id: UUID = Path(..., alias='projectId'),
    published_name: str = Path(..., alias='publishedName'),
    application: Optional[str] = None,
    body: ImageUrl = ...,
):
    """
    Detect objects in an image url without saving the result.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
